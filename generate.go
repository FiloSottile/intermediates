// Copyright 2021 Google LLC
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

//go:build generate
// +build generate

package main

import (
	"bytes"
	"compress/flate"
	"crypto/sha256"
	"crypto/x509"
	"encoding/csv"
	"encoding/pem"
	"io"
	"log"
	"net/http"
	"os"
	"sort"
	"text/template"
	"time"
)

//go:generate go run generate.go

// ccadb is from https://wiki.mozilla.org/CA/Intermediate_Certificates.
const ccadb = "https://ccadb-public.secure.force.com/mozilla/MozillaIntermediateCertsCSVReport"

type intermediate struct {
	Subject, Issuer string
	PEM             string
	Hash            [sha256.Size]byte
}

func main() {
	c := &http.Client{Timeout: 1 * time.Minute}
	req, err := c.Get(ccadb)
	fatalIfErr(err)
	defer req.Body.Close()
	if req.StatusCode != http.StatusOK {
		log.Fatalf("GET got %d: %v", req.StatusCode, req.Status)
	}

	var intermediates []intermediate
	seen := make(map[[sha256.Size]byte]bool)

	r := csv.NewReader(req.Body)
	header, err := r.Read()
	fatalIfErr(err)
	if header[4] != "PEM" {
		log.Fatal("Format changed.")
	}

	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		fatalIfErr(err)

		b, _ := pem.Decode([]byte(record[4]))
		if b == nil {
			log.Fatalf("Record is not valid PEM: %#v", record)
		}
		if _, err := x509.ParseCertificate(b.Bytes); err != nil {
			log.Printf("%#v", record)
			log.Fatalf("Invalid certificate: %v", err)
		}
		hash := sha256.Sum256(b.Bytes)
		if seen[hash] {
			log.Printf("Duplicate record: %v", record[0])
			continue
		}
		seen[hash] = true

		intermediates = append(intermediates, intermediate{
			Subject: record[0], Issuer: record[1],
			PEM: record[4], Hash: hash,
		})
	}

	sort.Slice(intermediates, func(i, j int) bool {
		if intermediates[i].Issuer != intermediates[j].Issuer {
			return intermediates[i].Issuer < intermediates[j].Issuer
		}
		if intermediates[i].Subject != intermediates[j].Subject {
			return intermediates[i].Subject < intermediates[j].Subject
		}
		return bytes.Compare(intermediates[i].Hash[:], intermediates[j].Hash[:]) < 0
	})

	text, err := os.Create("intermediates.pem")
	fatalIfErr(err)
	defer func() { fatalIfErr(text.Close()) }()
	zf, err := os.Create("intermediates.bin")
	fatalIfErr(err)
	defer func() { fatalIfErr(zf.Close()) }()
	zw, err := flate.NewWriter(zf, flate.DefaultCompression)
	fatalIfErr(err)
	defer func() { fatalIfErr(zw.Close()) }()

	for _, i := range intermediates {
		io.WriteString(text, "# Issuer: "+i.Issuer+"\n")
		io.WriteString(text, "# Subject: "+i.Subject+"\n")
		io.WriteString(text, i.PEM)
		io.WriteString(text, "\n")
		io.WriteString(zw, i.PEM)
		io.WriteString(zw, "\n")
	}

	f, err := os.Create("count.go")
	fatalIfErr(err)
	defer func() { fatalIfErr(f.Close()) }()

	tmpl.Execute(f, len(intermediates))

	log.Printf("Wrote %d intermediates.", len(intermediates))
}

var tmpl = template.Must(template.New("count.go").Parse(
	`// Code generated by generate.go. DO NOT EDIT.

package intermediates

const expectedCount = {{ . }}
`))

func fatalIfErr(err error) {
	if err != nil {
		log.Panic(err)
	}
}
